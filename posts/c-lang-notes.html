<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C Language Notes - Chuyang Liu</title><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" crossorigin="anonymous"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/base16/equilibrium-light.min.css" crossorigin="anonymous"><link rel="stylesheet" href="/style/default.css"></head><body><div class="container"><div class="row"><div class="col-sm-1"></div><div class="col-sm-10"><h1>C Language Notes</h1><hr><ol><li><blockquote><p>Since <code>int</code> is the default return type, it could be omitted.</p><footer>The C Programming Language (2nd Edition), P31</footer></blockquote></li><li><blockquote><p>Each local variable in a function comes into existence only when the function is called, and disappears when the function is exited. This is why such variables are usually known as <em>automatic</em> variables, following terminology in other languages.</p><footer>The C Programming Language (2nd Edition), P32</footer></blockquote></li><li><blockquote><p>In certain circumstances, the <code>extern</code> declaration can be omitted. If the definition of the external variable occurs in the source file before its use in a particular function, then there is no need for an <code>extern</code> declaration in the function.</p><p>If the program is in several source files, and a variable is defined in <em>file1</em> and used in <em>file2</em> and <em>file3</em>, then <code>extern</code> declarations are needed in <em>file2</em> and <em>file3</em> to connect the occurrences of the variable. The usual practice is to collect <code>extern</code> declarations of variables and functions in a separate file, historically called a <em>header</em>, that is included by <code>#include</code> at the front of each source file.</p><footer>The C Programming Language (2nd Edition), P33</footer></blockquote></li><li><blockquote><p>The direction of truncation for <code>/</code> and the sign of the result for <code>%</code> are machine-dependent for negative operands, as is the action taken on overflow or underflow.</p><footer>The C Programming Language (2nd Edition), P40</footer></blockquote></li><li><blockquote><p>The definition of C guarantees that any character in the machine&#39;s standard printing character set will never be negative, so these characters will always be positive quantities in expressions. But arbitrary bit patterns stored in character variables may appear to be negative on some machines, yet positive on others. For portability, specify <code>signed</code> or <code>unsigned</code> if non-character data is to be stored in <code>char</code> variables.</p><footer>The C Programming Language (2nd Edition), P42</footer></blockquote></li><li><blockquote><p>Conversion rules are more complicated when <code>unsigned</code> operands are involved. The problem is that comparisons between signed and unsigned values are machine-dependent, because they depend on the sizes of the various integer types. For example, suppose that <code>int</code> is 16 bits and <code>long</code> is 32 bits. Then <code>-1L &lt; 1U</code>, because <code>1U</code>, which is an <code>unsigned int</code>, is promoted to a <code>signed long</code>. But <code>-1L &gt; 1UL</code> because <code>-1L</code> is promoted to <code>unsigned long</code> and thus appears to be a large positive number.</p><footer>The C Programming Language (2nd Edition), P43</footer></blockquote></li><li><blockquote><p>Right shifting an <code>unsigned</code> quantity always fits the vacated bits with zero. Right shifting a signed quantity will fill with bit signs (&quot;arithmetic shift&quot;) on some machines and with 0-bits (&quot;logical shift&quot;) on others.</p><footer>The C Programming Language (2nd Edition), P47</footer></blockquote></li><li><blockquote><p>For example, if <code>f</code> is a <code>float</code> and <code>n</code> an <code>int</code>, then the expression</p><pre><code class="language-c">(n &gt; 0) ? f : n
</code></pre><p>is of type <code>float</code> regardless of whether <code>n</code> is positive.</p><footer>The C Programming Language (2nd Edition), P49</footer></blockquote></li><li><blockquote><p>C, like most languages, does not specify the order in which the operands of an operator are evaluated. (The exceptions are <code>&amp;&amp;</code>, <code>||</code>, <code>?:</code>, and <code>,</code>.) For example, in a statement like</p><pre><code class="language-c">x = f() + g();
</code></pre><p><code>f</code> may be evaluated before <code>g</code> or vice versa; thus if either <code>f</code> or <code>g</code> alters a variable on which the other depends, <code>x</code> can depend on the order of evaluation. Intermediate results can be stored in temporary variables to ensure a particular sequence.</p><p>Similarly, the order in which function arguments are evaluated is not specified, so the statement</p><pre><code class="language-c">printf(&quot;%d %d\n&quot;, ++n, power(2, n)); /* WRONG */
</code></pre><p>can produce different results with different compilers, depending on whether <code>n</code> is incremented before <code>power</code> is called.</p><p>In any expression involving side effects, there can be subtle dependencies on the order in which variables taking part in the expression are updated. One unhappy situation is typified by the statement</p><pre><code class="language-c">a[i] = i++;
</code></pre><p>The question is whether the subscript is the old value of <code>i</code> or the new.</p><footer>The C Programming Language (2nd Edition), P50-51</footer></blockquote></li><li><blockquote><p>Furthermore, if a function declaration does not include arguments, as in</p><pre><code class="language-c">double atof();
</code></pre><p>that too is taken to mean that nothing is to be assumed about the arguments of <code>atof</code>; all parameter checking is turned off. This special meaning of the empty argument list is intended to permit older C programs to compile with new compilers. But it&#39;s a bad idea to use it with new C programs. If the function takes arguments, declare them; if it takes no arguments, use <code>void</code>.</p><footer>The C Programming Language (2nd Edition), P66</footer></blockquote></li><li><blockquote><p>By default, external variables and functions have the property that all references to them by the same name, even from functions compiled separately, are references to the same thing. (The standard calls this property <em>external linkage</em>.)</p><footer>The C Programming Language (2nd Edition), P67</footer></blockquote></li><li><blockquote><p>A <code>register</code> declaration advises the compiler that the variable in question will be heavily used. The idea is that <code>register</code> variables are to be placed in machine registers, which may result in smaller and faster programs. But compilers are free to ignore the advice.</p><p>The <code>register</code> declaration looks like</p><pre><code class="language-c">register int x;
register char c;
</code></pre><p>and so on. The <code>register</code> declaration can only be applied to automatic variables and to the formal parameters of a function. In this later case, it looks like</p><pre><code class="language-c">f(register unsigned m, register long n)
{
    register int i;
    ...
}
</code></pre><p>In practice, there are restrictions on register variables, reflecting the realities of underlying hardware. Only a few variables in each function may be kept in registers, and only certain types are allowed. Excess register declarations are harmless, however, since the word <code>register</code> is ignored for excess or disallowed declarations. And it is not possible to take the address of a register variable, regardless of whether the variable is actually placed in a register. The specific restrictions on number and types of register variables vary from machine to machine.</p><footer>The C Programming Language (2nd Edition), P76</footer></blockquote></li><li><blockquote><p>Names may be undefined with <code>#undef</code>, usually to ensure that a routine is really a function, not a macro:</p><pre><code class="language-c">#undef getchar

int getchar(void) { ... }
</code></pre><footer>The C Programming Language (2nd Edition), P81</footer></blockquote></li><li><blockquote><p>Formal parameters are not replaced within quoted strings. If, however, a parameter name is preceded by a <code>#</code> in the replacement text, the combination will be expanded into a quoted string with the parameter replaced by the actual argument. This can be combined with string concatenation to make, for example, a debugging print macro:</p><pre><code class="language-c">#define dprint(expr) printf(#expr &quot; = %g\n&quot;, expr)
</code></pre><p>When this is invoked, as in</p><pre><code class="language-c">dprint(x/y);
</code></pre><p>the macro is expanded into</p><pre><code class="language-c">printf(&quot;x/y&quot; &quot; = &amp;g\n&quot;, x/y);
</code></pre><p>and the strings are concatenated, so the effect is</p><pre><code class="language-c">printf(&quot;x/y = &amp;g\n&quot;, x/y);
</code></pre><p>Within the actual argument, each <code>&quot;</code> is replaced by <code>\&quot;</code> and each <code>\</code> by <code>\\</code>, so the result is a legal string constant.</p><footer>The C Programming Language (2nd Edition), P81</footer></blockquote></li><li><blockquote><p>The preprocessor operator <code>##</code> provides a way to concatenate actual arguments during macro expansion. If a parameter in the replacement text is adjacent to a <code>##</code>, the parameter is replaced by the actual argument, the <code>##</code> and surrounding white space are removed, and the result is re-scanned. For example, the macro <code>paste</code> concatenates its two arguments:</p><pre><code class="language-c">#define paste(front, back) front ## back
</code></pre><p>so <code>paste(name, 1)</code> creates the token <code>name1</code>.</p><footer>The C Programming Language (2nd Edition), P81</footer></blockquote></li><li><blockquote><p>There is one difference between an array name and a pointer that must be kept in mind. A pointer is a variable, so <code>pa=a</code> and <code>pa++</code> are legal. But an array name is not a variable; constructions like <code>a=pa</code> and <code>a++</code> are illegal.</p><footer>The C Programming Language (2nd Edition), P89</footer></blockquote></li><li><blockquote><p>If one is sure that the elements exist, it is also possible to index backwards in an array; <code>p[-1]</code>, <code>p[-2]</code>, and so on are syntactically legal, and refer to the elements that immediately precede <code>p[0]</code>. Of course, it is illegal to refer to objects that are not within the array bounds.</p><footer>The C Programming Language (2nd Edition), P90</footer></blockquote></li><li><blockquote><p>There is an important difference between these definitions:</p><pre><code class="language-c">char amessage[] = &quot;now is the time&quot;;  /* an array */
char *pmessage = &quot;now is the time&quot;;   /* a pointer */
</code></pre><p><code>amessage</code> is an array, just big enough to hold the sequence of characters and <code>&#39;\0&#39;</code> that initializes it. Individual characters within the array may be changed but <code>amessage</code> will always refer to the same storage. On the other hand, <code>pmessage</code> is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string contents.</p><p><a href="https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha">[Details]</a></p><footer>The C Programming Language (2nd Edition), P93-94</footer></blockquote></li><li><blockquote><p><strong>Bit-fields</strong></p><p>A <strong>bit-field</strong>, or <strong>field</strong> for short, is a set of adjacent bits within a single implementation-defined storage unit that we will call a &quot;word&quot;. For example, the symbol table <code>#define</code>s above could be replaced by the definition of three fields:</p><pre><code class="language-c">struct {
    unsigned int is_keyword : 1;
    unsigned int is_extern : 1;
    unsigned int is_static : 1;
} flags;
</code></pre><p>This defines a variable table called <code>flags</code> that contains three 1-bit fields. The number following the colon represents the field width in bits. The fields are declared <code>unsigned int</code> to ensure that they are unsigned quantities.</p><p>Fields behave like small integers, and may participate in arithmetic expressions just like other integers. Thus the previous examples may be written more naturally as</p><pre><code class="language-c">flags.is_extern = flags.is_static = 1;
</code></pre><p>to turn the bits on;</p><pre><code class="language-c">flags.is_extern = flags.is_static = 0;
</code></pre><p>to turn them off; and</p><pre><code class="language-c">if (flags.is_extern == 0 &amp;&amp; flags.is_static == 0)
</code></pre><p>to test them.</p><p>Almost everything about fields is implementation-dependent. Whether a field may overlap a word boundary is implementation-defined. Fields need not be names; unnamed fields (a colon and width only) are used for padding. The special width 0 may be used to force alignment at the next word boundary.</p><p>Fields are assigned left to right on some machines and right to left on others. This means that although fields are useful for maintaining internally-defined data structures, the question of which end comes first has to be carefully considered when picking apart externally-defined data; programs that depend on such things are not portable. Fields may be declared only as ints; for portability, specify <code>signed</code> or <code>unsigned</code> explicitly. They are not arrays and they do not have addresses, so the &amp; operator cannot be applied on them.</p><footer>The C Programming Language (2nd Edition), P133-134</footer></blockquote></li><li><blockquote><p>Between the <code>%</code> and the conversion character there may be, in order:</p><ul><li>A minus sign, which specifies left adjustment of the converted argument.</li><li>A number that specifies the <em>minimum</em> field width. The converted argument will be printed in a field at least this wide. If necessary it will be padded on the left (or right, if left adjustment is called for) to make up the field width.</li><li>A period, which separates the field width from the precision.</li><li>A number, the precision, that specifies the <em>maximum</em> number of characters to be printed from a string, or the number of digits after the decimal point of a floating-point value, or the minimum number of digits for an integer.</li><li>An <code>h</code> if the integer is to be printed as a <code>short</code>, or <code>l</code> (letter ell) if as a <code>long</code>.</li></ul><br><footer>The C Programming Language (2nd Edition), P137</footer></blockquote></li><li><blockquote><p>A width or precision may be specified as <code>*</code>, in which case the value is computed by converting the next argument (which must be an <code>int</code>). For example, to print at most <code>max</code> characters from a string s,</p><pre><code class="language-c">printf(&quot;%.*s&quot;, max, s);
</code></pre><footer>The C Programming Language (2nd Edition), P138</footer></blockquote></li><li><blockquote><p>The function <code>sprintf</code> does the same conversions as <code>printf</code> does, but stores the output in a string:</p><pre><code class="language-c">int sprintf(char *string, char *format, arg1, arg2, ...);
</code></pre><p><code>sprintf</code> formats the arguments in <code>arg1</code>, <code>arg2</code>, etc., according to <code>format</code> as before, but places the result in <code>string</code> instead of the standard output; <code>string</code> must be big enough to receive the result.</p><p>There is also a function <code>sscanf</code> that reads from a string instead of the standard input:</p><pre><code class="language-c">int sscanf(char *string, char *format, arg1, arg2, ...)
</code></pre><p>It scans the <code>string</code> according to the <code>format</code> in format and stores the resulting values through <code>arg1</code>, <code>arg2</code>, etc. These arguments must be pointers.</p><footer>The C Programming Language (2nd Edition), P138, 140</footer></blockquote></li><li><blockquote><p><strong>Variable-length Argument Lists</strong></p><p>The proper declaration for <code>printf</code> is</p><pre><code class="language-c">int printf(char *fmt, ...)
</code></pre><p>where the declaration <code>...</code> means that the number and types of these arguments may vary. The declaration <code>...</code> can only appear at the end of an argument list.</p><pre><code class="language-c">#include &lt;stdarg.h&gt;

/* minprintf: minimal printf with variable argument list */
void minprintf(char *fmt, ...) {
    va_list ap;  /* points to each unnamed arg in turn */
    char *p, *sval;
    int ival;
    double dval;
    va_start(ap, fmt);  /* make ap point to 1st unnamed arg */
    for (p = fmt; *p; p++) {
        if (*p != &#39;%&#39;) {
            putchar(*p);
            continue;
        }
        switch (*++p) {
            case &#39;d&#39;:
                ival = va_arg(ap, int);
                printf(&quot;%d&quot;, ival);
                break;
            case &#39;f&#39;:
                dval = va_arg(ap, double);
                printf(&quot;%f&quot;, dval);
                break;
            case &#39;s&#39;:
                for (sval = va_arg(ap, char *); *sval; sval++)
                    putchar(*sval);
                break;
            default:
                putchar(*p);
                break;
        }
    }
    va_end(ap);  /* clean up when done */
}
</code></pre><footer>The C Programming Language (2nd Edition), P138-139</footer></blockquote></li><li><blockquote><p>When a C program is started, the operating system environment is responsible for opening three files and providing pointers for them. These files are the standard input, the standard output, and the standard error; the corresponding file pointers are called <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>, and are declared in <code>&lt;stdio.h&gt;</code>. Normally <code>stdin</code> is connected to the keyboard and <code>stdout</code> and <code>stderr</code> are connected to the screen.</p><footer>The C Programming Language (2nd Edition), P143-144</footer></blockquote></li><li><blockquote><p>Output written on <code>stderr</code> normally appears on the screen even if the standard output is redirected.</p><p>Let us revise <code>cat</code> to write its error messages on the standard error.</p><pre><code class="language-c">#include &lt;stdio.h&gt;
/* cat: concatenate files, version 2 */
main(int argc, char *argv[])
{
    FILE *fp;
    void filecopy(FILE *, FILE *);
    char *prog = argv[0];  /* program name for errors */
    if (argc == 1 )  /* no args; copy standard input */
        filecopy(stdin, stdout);
    else
        while (--argc &gt; 0)
            if ((fp = fopen(*++argv, &quot;r&quot;)) == NULL) {
                fprintf(stderr, &quot;%s: can&#39;t open %s\n&quot;,
                prog, *argv);
                exit(1);
            } else {
                filecopy(fp, stdout);
                fclose(fp);
            }
    if (ferror(stdout)) {
        fprintf(stderr, &quot;%s: error writing stdout\n&quot;, prog);
        exit(2);
    }
    exit(0);
}
</code></pre><p>The program uses the standard library function <code>exit</code>, which terminates program execution when it is called. The argument of <code>exit</code> is available to whatever process called this one, so the success or failure of the program can be tested by another program that uses this one as a sub-process. <code>exit</code> calls <code>fclose</code> for each open output file, to flush out any buffered output.</p><p>Within <code>main</code>, <code>return (expr)</code> is equivalent to <code>exit(expr)</code>. <code>exit</code> has the advantage that it can be called from other functions,</p><footer>The C Programming Language (2nd Edition), P145-146</footer></blockquote></li></ol><footer class="page-footer"><hr><ul class="list-inline"><li><p>&copy; 2024 Chuyang Liu</p></li><li><a href="/">About</a></li><li><a href="/posts/">Posts</a></li><li><a href="https://github.com/chuyangliu/">GitHub</a></li></ul></footer></div><div class="col-sm-1"></div></div></div><script src="https://fastly.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js" crossorigin="anonymous"></script><script src="https://fastly.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" crossorigin="anonymous"></script><script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js" crossorigin="anonymous"></script><script src="/script/default.js"></script></body></html>