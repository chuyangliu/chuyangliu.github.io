<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Sum Tree | Chuyang Liu</title><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" crossorigin="anonymous"><link rel="stylesheet" href="/style/default.css"></head><body><div class="container"><div class="row"><div class="col-sm-1"></div><div class="col-sm-10"><h1>Sum Tree</h1><hr><p>Sum tree is a data structure based on <a href="https://en.wikipedia.org/wiki/Binary_heap">binary heap</a>. Besides basic heap properties, the value of each node in a sum tree equals to the sum of the values from the two child nodes. DeepMind used this data structure to efficiently sample data according to their priorities<sup><a href="https://arxiv.org/abs/1511.05952/">[1]</a></sup>. Concretely, nodes with higher value (priority) are more likely to be sampled in a sum tree. The time complexity of sampling and updating a sum tree is \(O \left( \log n \right)\), where \(n\) is the number of nodes in the tree. <a href="https://github.com/chuyangliu/Snake/blob/master/snake/util/sumtree.py">Here</a> is one example implementation of the data structure.</p><h2 id="definitions">Definitions</h2><table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td>\(n\)</td><td>Number of nodes in a sum tree.</td></tr><tr><td>\(a_i \left( 1 \leqslant i \leqslant n \right)\)</td><td>One specific node in a sum tree, where \(i\) is the same as the index of the array representation of a binary heap, with \(a_1\) indicating the root node, \(a_{i*2}\) indicating the left child of node \(a_i\), and \(a_{i*2+1}\) indicating the right child of node \(a_i\).</td></tr><tr><td>\(parent \left( a_i \right)\)</td><td>Parent node of node \(a_i\).</td></tr><tr><td>\(v \left( a_i \right)\)</td><td>Value of node \(a_i\). If \(a_i\) is a leaf node, \(v \left( a_i \right)\) is the priority of the data associated with it. Otherwise, \(v \left( a_i \right)\) is the sum of the values from its two child nodes.</td></tr><tr><td>\(P \left( a_i \right)\)</td><td>Probability that node \(a_i\) is <strong>visited</strong> (explained in the example below).</td></tr></tbody></table><h2 id="example">Example</h2><p>Suppose we have a data set of 8 elements with priority values being 3, 10, 12, 4, 1, 2, 8, 2, respectively. Now we want to sample elements from this data set, and expect that elements with higher priority are more likely to be sampled. To solve this problem, we can build a sum tree below:</p><p><img src="/media/sum_tree.png" alt=""></p><p>From the picture above, we can see that the tree has 8 leaf nodes storing the priority values of the 8 elements. The value of each inner node is the sum of the values from both child nodes. Therefore, the value of the root node is the sum of all priority values, which is 42.</p><p>To sample one element, we first uniformly sample a number within the interval [0, 42], and suppose we get the number 24. We then start at the root node and look at its left child (with value 29). Finding that 24 \(\leqslant\) 29, we move from the root node to the left child. Looking at its left child (with value 13), we find 24 \(\nleqslant\) 13, so we move to the right child (with value 16). Since we pass the left child, we subtract 13 from 24 and consider 11 (=24-13) as the new number for traversing. Sitting on the node with value 16, we look at the left child (with value 12) and find that 11 \(\leqslant\) 12, so we move to the left child. Since we reach a leaf node, we sample the element with priority specified in the node. In this example, the element with priority 12 is sampled. Throughout the process, we have <strong>visited</strong> node \(a_1\), \(a_2\), \(a_5\), and \(a_{10}\).</p><p>The sampling process described above ensures that when \(1 \leqslant i \leqslant n\),</p><p>$$ P \left( a_i \right) = \dfrac{v \left( a_i \right)}{v \left( a_1 \right)} \label{1} \tag{1} $$</p><h2 id="proof">Proof</h2><p>Obviously, equation \(\ref{1}\) holds when \(i=1\) because the root node will always be visited:</p><p>$$ P \left( a_1 \right) = 1 = \dfrac{v \left( a_1 \right)}{v \left( a_1 \right)} $$</p><p>To prove equation \(\ref{1}\) holds when \(i&gt;1\), we can start with a small sum tree with 3 nodes:</p><p><img src="/media/sum_tree_trivial.png" alt=""></p><p>According to the sampling method, we start by sampling a number within the interval \( \left[ 0, a+b \right] \). Suppose we get the number \(x\). If \(x \leqslant a\), the left child will be sampled. Otherwise, we will sample the right child. Therefore,</p><p>$$ \begin{align} P \left( a_2 \right) &amp;= P \left( 0 \leqslant x \leqslant a \right) = \dfrac{a}{a+b} = \dfrac{v \left( a_2 \right)}{v \left( a_1 \right)} \\ P \left( a_3 \right) &amp;= P \left( a &lt; x \leqslant a+b \right) = \dfrac{b}{a+b} = \dfrac{v \left( a_3 \right)}{v \left( a_1 \right)} \end{align} $$</p><p>Since every sum tree can be constructed recursively from several small sum trees mentioned above, we can derive that</p><p>$$ \begin{align} P \left( a_i \right) &amp;= P \left( parent \left( a_i \right) \right) P \left( a_i \mid parent \left( a_i \right) \right) \\ &amp;= P \left( parent \left( a_i \right) \right) \dfrac{v \left( a_i \right)}{v \left( parent \left( a_i \right) \right)} \quad \left( 1 \leqslant i \leqslant n \right) \end{align} \label{2} \tag{2} $$</p><p>We can solve equation \(\ref{2}\) recursively:</p><p>$$ \begin{align} P \left( a_i \right) &amp;= P \left( parent \left( a_i \right) \right) \dfrac{v \left( a_i \right)}{v \left( parent \left( a_i \right) \right)} \label{3} \tag{3} \\ P \left( parent \left( a_i \right) \right) &amp;= P \left( parent \left( parent \left( a_i \right) \right) \right) \dfrac{v \left( parent \left( a_i \right) \right)}{v \left( parent \left( parent \left( a_i \right) \right) \right)} \label{4} \tag{4} \\ \dots \tag{...} \\ P \left( parent \left( \dots \right) \right) &amp;= P \left( a_1 \right) \dfrac{v \left( parent \left( \dots \right) \right)}{v \left( a_1 \right)} \label{k} \tag{k} \end{align} $$</p><p>Multiply equations \(\ref{3} \thicksim \ref{k}\). We can get:</p><p>$$ P \left( a_i \right) = P \left( a_1 \right) \dfrac{v \left( a_i \right)}{v \left( a_1 \right)} = \dfrac{v \left( a_i \right)}{v \left( a_1 \right)} $$</p><p>Therefore, equation \(\ref{1}\) holds when \(i&gt;1\) as well.</p><p>In conclusion, equation \(\ref{1}\) holds when \(1 \leqslant i \leqslant n\).</p><footer class="page-footer"><hr><ul class="list-inline"><li><p>&copy; 2024 Chuyang Liu</p></li><li><a href="/">About</a></li><li><a href="/posts/">Posts</a></li><li><a href="https://github.com/chuyangliu/">GitHub</a></li></ul></footer></div><div class="col-sm-1"></div></div></div><script src="https://fastly.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js" crossorigin="anonymous"></script><script src="https://fastly.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" crossorigin="anonymous"></script><script src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" crossorigin="anonymous" async="async"></script><script src="/script/default.js"></script></body></html>